package jp.co.soramitsu.sora.json

import com.fasterxml.jackson.databind.ObjectMapper
import com.fasterxml.jackson.databind.node.ObjectNode
import jp.co.soramitsu.sora.crypto.json.flattener.DeflattenException
import jp.co.soramitsu.sora.crypto.json.flattener.Flattener
import spock.genesis.Gen
import spock.lang.Specification
import spock.lang.Unroll

class FlattenerTest extends Specification {

    def mapper = new ObjectMapper()
    def flattener = new Flattener()

    def initial = mapper.readTree(this.getClass().getResourceAsStream('/json/_initial.json'))
    def flattened = mapper.readTree(this.getClass().getResourceAsStream('/json/flattened.json'))

    def "isFlattened works"() {
        given:
        initial
        flattened

        when:
        def f1 = flattener.isFlattened(initial)
        def f2 = flattener.isFlattened(flattened)

        then:
        !f1
        f2
    }

    def "flatten works"() {
        given:
        initial
        flattened

        when:
        def flatActual = flattener.flatten(initial)

        then:
        flatActual == flattened
    }

    ObjectNode deepgen(int level, it) {
        if (level <= 0) {
            return null
        }

        ObjectNode last = mapper.createObjectNode() as ObjectNode
        last.set(it.next(), deepgen(level - 1, it))
        return last
    }

    def "deep jsons are handled properly"() {
        given:
        def deep = deepgen(levels, it)

        when:
        def flat = flattener.flatten(deep)

        then:
        flattener.isFlattened(flat)
        flat.size() == 1

        where:
        // maximum nesting levels, iterator
        levels | it
        100    | Gen.string(100).iterator()  // autogenerated key
        100    | Gen.string(~/same/).iterator()         // same key
    }

    @Unroll
    def "flatten then deflatten works for #json"() {
        given:
        def mapper = Spy(ObjectMapper)
        def flattener = new Flattener(mapper)

        when: "flatten then deflatten"
        def original = mapper.valueToTree(json)
        def flat = flattener.flatten(original as ObjectNode)
        def actual = flattener.deflatten(flat)

        then: "same as the original"
        actual == original

        where:
        _ | json
        _ | ["a": 1]
        _ | ["c": ["1", 1]]
        _ | ["d": [["e": 2, "f": []]]]
        _ | ["g": ["h": null, "j": "z"]]
        _ | ["deep": ["deep": ["deep": ["deep": ["deep": []]]]]]
        _ | ["a": [[[[[:]]]]]]
        _ | [
                "value"        : 1,
                "arrayOfValues": [1, 2, 3, 4, 5, 6],
                "dictOfValues" : ["a": 1, "b": 2],
                "arrayOfArrays": [[], [], []],
                "arrayOfDicts" : [[:], [:], [:]],
                "dictOfArrays" : ["a": [], "b": [], "c": []],
                "dictOfDicts"  : ["a": ["a": "a"], "b": ["b": "b"]],
                "null"         : null
        ]
    }

    @Unroll
    def "invalid deflatten #flat"() {
        given:
        def mapper = new ObjectMapper()
        def flattener = new Flattener()
        def flatNode = mapper.valueToTree(flat)

        when:
        flattener.deflatten(flatNode as ObjectNode)

        then:
        thrown(DeflattenException)

        where:
        _ | flat
        _ | ["_0": "array"]
        _ | ["_": "_"]
        _ | ["": "empty"]
        _ | ["string": "string"]
    }

}
